// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/google/uuid"
	"github.com/kiremitrov123/onboarding/commenting/model"
	"github.com/kiremitrov123/onboarding/commenting/service"
	"sync"
)

// Ensure, that CommentRepoMock does implement service.CommentRepo.
// If this is not the case, regenerate this file with moq.
var _ service.CommentRepo = &CommentRepoMock{}

// CommentRepoMock is a mock implementation of service.CommentRepo.
//
//	func TestSomethingThatUsesCommentRepo(t *testing.T) {
//
//		// make and configure a mocked service.CommentRepo
//		mockedCommentRepo := &CommentRepoMock{
//			AddReactionFunc: func(ctx context.Context, reaction *model.Reaction) (bool, error) {
//				panic("mock out the AddReaction method")
//			},
//			CreateCommentFunc: func(ctx context.Context, comment *model.Comment) error {
//				panic("mock out the CreateComment method")
//			},
//			DecrementReactionCountFunc: func(ctx context.Context, commentID uuid.UUID, field string) error {
//				panic("mock out the DecrementReactionCount method")
//			},
//			DeleteReactionFunc: func(ctx context.Context, commentID uuid.UUID, userID string, reactionType string) error {
//				panic("mock out the DeleteReaction method")
//			},
//			GetCommentByIDFunc: func(ctx context.Context, commentID uuid.UUID) (*model.Comment, error) {
//				panic("mock out the GetCommentByID method")
//			},
//			IncrementReactionCountFunc: func(ctx context.Context, commentID uuid.UUID, field string) error {
//				panic("mock out the IncrementReactionCount method")
//			},
//			IncrementReplyCountFunc: func(ctx context.Context, parentID uuid.UUID) error {
//				panic("mock out the IncrementReplyCount method")
//			},
//			ListCommentsSortedFunc: func(ctx context.Context, threadID uuid.UUID, sortField string, cursor int64, limit int) ([]model.Comment, error) {
//				panic("mock out the ListCommentsSorted method")
//			},
//		}
//
//		// use mockedCommentRepo in code that requires service.CommentRepo
//		// and then make assertions.
//
//	}
type CommentRepoMock struct {
	// AddReactionFunc mocks the AddReaction method.
	AddReactionFunc func(ctx context.Context, reaction *model.Reaction) (bool, error)

	// CreateCommentFunc mocks the CreateComment method.
	CreateCommentFunc func(ctx context.Context, comment *model.Comment) error

	// DecrementReactionCountFunc mocks the DecrementReactionCount method.
	DecrementReactionCountFunc func(ctx context.Context, commentID uuid.UUID, field string) error

	// DeleteReactionFunc mocks the DeleteReaction method.
	DeleteReactionFunc func(ctx context.Context, commentID uuid.UUID, userID string, reactionType string) error

	// GetCommentByIDFunc mocks the GetCommentByID method.
	GetCommentByIDFunc func(ctx context.Context, commentID uuid.UUID) (*model.Comment, error)

	// IncrementReactionCountFunc mocks the IncrementReactionCount method.
	IncrementReactionCountFunc func(ctx context.Context, commentID uuid.UUID, field string) error

	// IncrementReplyCountFunc mocks the IncrementReplyCount method.
	IncrementReplyCountFunc func(ctx context.Context, parentID uuid.UUID) error

	// ListCommentsSortedFunc mocks the ListCommentsSorted method.
	ListCommentsSortedFunc func(ctx context.Context, threadID uuid.UUID, sortField string, cursor int64, limit int) ([]model.Comment, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddReaction holds details about calls to the AddReaction method.
		AddReaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Reaction is the reaction argument value.
			Reaction *model.Reaction
		}
		// CreateComment holds details about calls to the CreateComment method.
		CreateComment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Comment is the comment argument value.
			Comment *model.Comment
		}
		// DecrementReactionCount holds details about calls to the DecrementReactionCount method.
		DecrementReactionCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CommentID is the commentID argument value.
			CommentID uuid.UUID
			// Field is the field argument value.
			Field string
		}
		// DeleteReaction holds details about calls to the DeleteReaction method.
		DeleteReaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CommentID is the commentID argument value.
			CommentID uuid.UUID
			// UserID is the userID argument value.
			UserID string
			// ReactionType is the reactionType argument value.
			ReactionType string
		}
		// GetCommentByID holds details about calls to the GetCommentByID method.
		GetCommentByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CommentID is the commentID argument value.
			CommentID uuid.UUID
		}
		// IncrementReactionCount holds details about calls to the IncrementReactionCount method.
		IncrementReactionCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CommentID is the commentID argument value.
			CommentID uuid.UUID
			// Field is the field argument value.
			Field string
		}
		// IncrementReplyCount holds details about calls to the IncrementReplyCount method.
		IncrementReplyCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ParentID is the parentID argument value.
			ParentID uuid.UUID
		}
		// ListCommentsSorted holds details about calls to the ListCommentsSorted method.
		ListCommentsSorted []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ThreadID is the threadID argument value.
			ThreadID uuid.UUID
			// SortField is the sortField argument value.
			SortField string
			// Cursor is the cursor argument value.
			Cursor int64
			// Limit is the limit argument value.
			Limit int
		}
	}
	lockAddReaction            sync.RWMutex
	lockCreateComment          sync.RWMutex
	lockDecrementReactionCount sync.RWMutex
	lockDeleteReaction         sync.RWMutex
	lockGetCommentByID         sync.RWMutex
	lockIncrementReactionCount sync.RWMutex
	lockIncrementReplyCount    sync.RWMutex
	lockListCommentsSorted     sync.RWMutex
}

// AddReaction calls AddReactionFunc.
func (mock *CommentRepoMock) AddReaction(ctx context.Context, reaction *model.Reaction) (bool, error) {
	if mock.AddReactionFunc == nil {
		panic("CommentRepoMock.AddReactionFunc: method is nil but CommentRepo.AddReaction was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Reaction *model.Reaction
	}{
		Ctx:      ctx,
		Reaction: reaction,
	}
	mock.lockAddReaction.Lock()
	mock.calls.AddReaction = append(mock.calls.AddReaction, callInfo)
	mock.lockAddReaction.Unlock()
	return mock.AddReactionFunc(ctx, reaction)
}

// AddReactionCalls gets all the calls that were made to AddReaction.
// Check the length with:
//
//	len(mockedCommentRepo.AddReactionCalls())
func (mock *CommentRepoMock) AddReactionCalls() []struct {
	Ctx      context.Context
	Reaction *model.Reaction
} {
	var calls []struct {
		Ctx      context.Context
		Reaction *model.Reaction
	}
	mock.lockAddReaction.RLock()
	calls = mock.calls.AddReaction
	mock.lockAddReaction.RUnlock()
	return calls
}

// CreateComment calls CreateCommentFunc.
func (mock *CommentRepoMock) CreateComment(ctx context.Context, comment *model.Comment) error {
	if mock.CreateCommentFunc == nil {
		panic("CommentRepoMock.CreateCommentFunc: method is nil but CommentRepo.CreateComment was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Comment *model.Comment
	}{
		Ctx:     ctx,
		Comment: comment,
	}
	mock.lockCreateComment.Lock()
	mock.calls.CreateComment = append(mock.calls.CreateComment, callInfo)
	mock.lockCreateComment.Unlock()
	return mock.CreateCommentFunc(ctx, comment)
}

// CreateCommentCalls gets all the calls that were made to CreateComment.
// Check the length with:
//
//	len(mockedCommentRepo.CreateCommentCalls())
func (mock *CommentRepoMock) CreateCommentCalls() []struct {
	Ctx     context.Context
	Comment *model.Comment
} {
	var calls []struct {
		Ctx     context.Context
		Comment *model.Comment
	}
	mock.lockCreateComment.RLock()
	calls = mock.calls.CreateComment
	mock.lockCreateComment.RUnlock()
	return calls
}

// DecrementReactionCount calls DecrementReactionCountFunc.
func (mock *CommentRepoMock) DecrementReactionCount(ctx context.Context, commentID uuid.UUID, field string) error {
	if mock.DecrementReactionCountFunc == nil {
		panic("CommentRepoMock.DecrementReactionCountFunc: method is nil but CommentRepo.DecrementReactionCount was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		CommentID uuid.UUID
		Field     string
	}{
		Ctx:       ctx,
		CommentID: commentID,
		Field:     field,
	}
	mock.lockDecrementReactionCount.Lock()
	mock.calls.DecrementReactionCount = append(mock.calls.DecrementReactionCount, callInfo)
	mock.lockDecrementReactionCount.Unlock()
	return mock.DecrementReactionCountFunc(ctx, commentID, field)
}

// DecrementReactionCountCalls gets all the calls that were made to DecrementReactionCount.
// Check the length with:
//
//	len(mockedCommentRepo.DecrementReactionCountCalls())
func (mock *CommentRepoMock) DecrementReactionCountCalls() []struct {
	Ctx       context.Context
	CommentID uuid.UUID
	Field     string
} {
	var calls []struct {
		Ctx       context.Context
		CommentID uuid.UUID
		Field     string
	}
	mock.lockDecrementReactionCount.RLock()
	calls = mock.calls.DecrementReactionCount
	mock.lockDecrementReactionCount.RUnlock()
	return calls
}

// DeleteReaction calls DeleteReactionFunc.
func (mock *CommentRepoMock) DeleteReaction(ctx context.Context, commentID uuid.UUID, userID string, reactionType string) error {
	if mock.DeleteReactionFunc == nil {
		panic("CommentRepoMock.DeleteReactionFunc: method is nil but CommentRepo.DeleteReaction was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		CommentID    uuid.UUID
		UserID       string
		ReactionType string
	}{
		Ctx:          ctx,
		CommentID:    commentID,
		UserID:       userID,
		ReactionType: reactionType,
	}
	mock.lockDeleteReaction.Lock()
	mock.calls.DeleteReaction = append(mock.calls.DeleteReaction, callInfo)
	mock.lockDeleteReaction.Unlock()
	return mock.DeleteReactionFunc(ctx, commentID, userID, reactionType)
}

// DeleteReactionCalls gets all the calls that were made to DeleteReaction.
// Check the length with:
//
//	len(mockedCommentRepo.DeleteReactionCalls())
func (mock *CommentRepoMock) DeleteReactionCalls() []struct {
	Ctx          context.Context
	CommentID    uuid.UUID
	UserID       string
	ReactionType string
} {
	var calls []struct {
		Ctx          context.Context
		CommentID    uuid.UUID
		UserID       string
		ReactionType string
	}
	mock.lockDeleteReaction.RLock()
	calls = mock.calls.DeleteReaction
	mock.lockDeleteReaction.RUnlock()
	return calls
}

// GetCommentByID calls GetCommentByIDFunc.
func (mock *CommentRepoMock) GetCommentByID(ctx context.Context, commentID uuid.UUID) (*model.Comment, error) {
	if mock.GetCommentByIDFunc == nil {
		panic("CommentRepoMock.GetCommentByIDFunc: method is nil but CommentRepo.GetCommentByID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		CommentID uuid.UUID
	}{
		Ctx:       ctx,
		CommentID: commentID,
	}
	mock.lockGetCommentByID.Lock()
	mock.calls.GetCommentByID = append(mock.calls.GetCommentByID, callInfo)
	mock.lockGetCommentByID.Unlock()
	return mock.GetCommentByIDFunc(ctx, commentID)
}

// GetCommentByIDCalls gets all the calls that were made to GetCommentByID.
// Check the length with:
//
//	len(mockedCommentRepo.GetCommentByIDCalls())
func (mock *CommentRepoMock) GetCommentByIDCalls() []struct {
	Ctx       context.Context
	CommentID uuid.UUID
} {
	var calls []struct {
		Ctx       context.Context
		CommentID uuid.UUID
	}
	mock.lockGetCommentByID.RLock()
	calls = mock.calls.GetCommentByID
	mock.lockGetCommentByID.RUnlock()
	return calls
}

// IncrementReactionCount calls IncrementReactionCountFunc.
func (mock *CommentRepoMock) IncrementReactionCount(ctx context.Context, commentID uuid.UUID, field string) error {
	if mock.IncrementReactionCountFunc == nil {
		panic("CommentRepoMock.IncrementReactionCountFunc: method is nil but CommentRepo.IncrementReactionCount was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		CommentID uuid.UUID
		Field     string
	}{
		Ctx:       ctx,
		CommentID: commentID,
		Field:     field,
	}
	mock.lockIncrementReactionCount.Lock()
	mock.calls.IncrementReactionCount = append(mock.calls.IncrementReactionCount, callInfo)
	mock.lockIncrementReactionCount.Unlock()
	return mock.IncrementReactionCountFunc(ctx, commentID, field)
}

// IncrementReactionCountCalls gets all the calls that were made to IncrementReactionCount.
// Check the length with:
//
//	len(mockedCommentRepo.IncrementReactionCountCalls())
func (mock *CommentRepoMock) IncrementReactionCountCalls() []struct {
	Ctx       context.Context
	CommentID uuid.UUID
	Field     string
} {
	var calls []struct {
		Ctx       context.Context
		CommentID uuid.UUID
		Field     string
	}
	mock.lockIncrementReactionCount.RLock()
	calls = mock.calls.IncrementReactionCount
	mock.lockIncrementReactionCount.RUnlock()
	return calls
}

// IncrementReplyCount calls IncrementReplyCountFunc.
func (mock *CommentRepoMock) IncrementReplyCount(ctx context.Context, parentID uuid.UUID) error {
	if mock.IncrementReplyCountFunc == nil {
		panic("CommentRepoMock.IncrementReplyCountFunc: method is nil but CommentRepo.IncrementReplyCount was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ParentID uuid.UUID
	}{
		Ctx:      ctx,
		ParentID: parentID,
	}
	mock.lockIncrementReplyCount.Lock()
	mock.calls.IncrementReplyCount = append(mock.calls.IncrementReplyCount, callInfo)
	mock.lockIncrementReplyCount.Unlock()
	return mock.IncrementReplyCountFunc(ctx, parentID)
}

// IncrementReplyCountCalls gets all the calls that were made to IncrementReplyCount.
// Check the length with:
//
//	len(mockedCommentRepo.IncrementReplyCountCalls())
func (mock *CommentRepoMock) IncrementReplyCountCalls() []struct {
	Ctx      context.Context
	ParentID uuid.UUID
} {
	var calls []struct {
		Ctx      context.Context
		ParentID uuid.UUID
	}
	mock.lockIncrementReplyCount.RLock()
	calls = mock.calls.IncrementReplyCount
	mock.lockIncrementReplyCount.RUnlock()
	return calls
}

// ListCommentsSorted calls ListCommentsSortedFunc.
func (mock *CommentRepoMock) ListCommentsSorted(ctx context.Context, threadID uuid.UUID, sortField string, cursor int64, limit int) ([]model.Comment, error) {
	if mock.ListCommentsSortedFunc == nil {
		panic("CommentRepoMock.ListCommentsSortedFunc: method is nil but CommentRepo.ListCommentsSorted was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ThreadID  uuid.UUID
		SortField string
		Cursor    int64
		Limit     int
	}{
		Ctx:       ctx,
		ThreadID:  threadID,
		SortField: sortField,
		Cursor:    cursor,
		Limit:     limit,
	}
	mock.lockListCommentsSorted.Lock()
	mock.calls.ListCommentsSorted = append(mock.calls.ListCommentsSorted, callInfo)
	mock.lockListCommentsSorted.Unlock()
	return mock.ListCommentsSortedFunc(ctx, threadID, sortField, cursor, limit)
}

// ListCommentsSortedCalls gets all the calls that were made to ListCommentsSorted.
// Check the length with:
//
//	len(mockedCommentRepo.ListCommentsSortedCalls())
func (mock *CommentRepoMock) ListCommentsSortedCalls() []struct {
	Ctx       context.Context
	ThreadID  uuid.UUID
	SortField string
	Cursor    int64
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		ThreadID  uuid.UUID
		SortField string
		Cursor    int64
		Limit     int
	}
	mock.lockListCommentsSorted.RLock()
	calls = mock.calls.ListCommentsSorted
	mock.lockListCommentsSorted.RUnlock()
	return calls
}
